# Data Types Reference

## Overview

Choosing the right data type is crucial for database performance, storage efficiency, and data integrity. This comprehensive reference covers common data types in MySQL and PostgreSQL with best practices and examples.

---

## Table of Contents

1. [Numeric Types](#numeric-types)
2. [String Types](#string-types)
3. [Date and Time Types](#date-and-time-types)
4. [Binary Types](#binary-types)
5. [Boolean Types](#boolean-types)
6. [JSON Types](#json-types)
7. [Array Types](#array-types)
8. [UUID and Custom Types](#uuid-and-custom-types)
9. [Type Selection Guidelines](#type-selection-guidelines)

---

## Numeric Types

### Integer Types

| Type | MySQL | PostgreSQL | Storage | Range |
|------|-------|------------|---------|-------|
| **TINYINT** | ✓ | - | 1 byte | -128 to 127 (signed) / 0 to 255 (unsigned) |
| **SMALLINT** | ✓ | ✓ | 2 bytes | -32,768 to 32,767 |
| **MEDIUMINT** | ✓ | - | 3 bytes | -8,388,608 to 8,388,607 |
| **INTEGER/INT** | ✓ | ✓ | 4 bytes | -2,147,483,648 to 2,147,483,647 |
| **BIGINT** | ✓ | ✓ | 8 bytes | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |

### Integer Examples

```sql
-- MySQL
CREATE TABLE products (
    product_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,  -- 0 to 4.2 billion
    category_id SMALLINT UNSIGNED,                        -- 0 to 65,535
    stock_quantity INT,                                   -- Can be negative
    views_count BIGINT UNSIGNED DEFAULT 0                 -- Very large numbers
);

-- PostgreSQL
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,           -- Auto-incrementing INT
    category_id SMALLINT,
    stock_quantity INTEGER,
    views_count BIGINT DEFAULT 0
);
```

### Auto-Increment Types

**MySQL:**
```sql
-- Traditional auto-increment
id INT AUTO_INCREMENT PRIMARY KEY

-- Unsigned for more capacity
id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY

-- Big tables
id BIGINT AUTO_INCREMENT PRIMARY KEY
```

**PostgreSQL:**
```sql
-- SERIAL (creates sequence automatically)
id SERIAL PRIMARY KEY                    -- INT, auto-increment
id BIGSERIAL PRIMARY KEY                 -- BIGINT, auto-increment
id SMALLSERIAL PRIMARY KEY               -- SMALLINT, auto-increment

-- IDENTITY (SQL standard, recommended in PostgreSQL 10+)
id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY
id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
```

### Decimal/Numeric Types

For exact precision (money, measurements, etc.).

| Type | Storage | Use Case |
|------|---------|----------|
| **DECIMAL(p,s)** | Variable | Exact precision, financial data |
| **NUMERIC(p,s)** | Variable | Same as DECIMAL |
| **FLOAT** | 4 bytes | Approximate, scientific calculations |
| **DOUBLE** | 8 bytes | Approximate, more precision than FLOAT |

- **p (precision):** Total number of digits
- **s (scale):** Number of digits after decimal point

```sql
-- Financial data - ALWAYS use DECIMAL
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    subtotal DECIMAL(10, 2),    -- Up to 99,999,999.99
    tax_amount DECIMAL(10, 2),
    total DECIMAL(10, 2)
);

-- Scientific measurements
CREATE TABLE measurements (
    measurement_id INT PRIMARY KEY,
    temperature FLOAT,          -- Approximate is OK
    precise_value DECIMAL(15, 6) -- High precision
);
```

### Best Practices: Numeric Types

✅ **Do:**
- Use SMALLINT for small ranges (age, quantity)
- Use INT for most IDs and counters
- Use BIGINT for large tables (>2 billion rows)
- Use DECIMAL for money (never FLOAT/DOUBLE)
- Use UNSIGNED in MySQL when negative values impossible

❌ **Don't:**
- Use FLOAT/DOUBLE for money (rounding errors!)
- Use BIGINT for everything (wastes space)
- Use TINYINT for IDs (runs out quickly)

---

## String Types

### Fixed vs Variable Length

**MySQL:**

| Type | Description | Max Size | Use Case |
|------|-------------|----------|----------|
| **CHAR(n)** | Fixed length | 255 bytes | Codes, fixed-length IDs |
| **VARCHAR(n)** | Variable length | 65,535 bytes | Names, emails |
| **TINYTEXT** | Variable text | 255 bytes | Short text |
| **TEXT** | Variable text | 65,535 bytes | Articles, descriptions |
| **MEDIUMTEXT** | Variable text | 16 MB | Long articles |
| **LONGTEXT** | Variable text | 4 GB | Very large text |

**PostgreSQL:**

| Type | Description | Max Size | Use Case |
|------|-------------|----------|----------|
| **CHAR(n)** | Fixed length | Any | Rarely used (use VARCHAR) |
| **VARCHAR(n)** | Variable length | Any | Most strings |
| **TEXT** | Variable text | 1 GB | Any text (same as unlimited VARCHAR) |

### String Examples

```sql
-- MySQL
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,           -- Variable, typical usernames
    email VARCHAR(255) NOT NULL,             -- 255 is enough for emails
    country_code CHAR(2),                    -- Fixed: 'US', 'UK', etc.
    biography TEXT,                          -- Long text
    notes MEDIUMTEXT                         -- Very long text
);

-- PostgreSQL
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL,
    country_code CHAR(2),
    biography TEXT,                          -- No size needed
    notes TEXT
);
```

### Character Sets and Collation

**MySQL:**
```sql
-- UTF-8 (use utf8mb4 for full Unicode support, including emojis)
CREATE TABLE posts (
    post_id INT PRIMARY KEY,
    title VARCHAR(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci,
    content TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- Case-sensitive collation
CREATE TABLE passwords (
    user_id INT,
    password_hash VARCHAR(255) COLLATE utf8mb4_bin  -- Binary, case-sensitive
);
```

**PostgreSQL:**
```sql
-- PostgreSQL uses UTF-8 by default
-- Set database-wide
CREATE DATABASE mydb ENCODING 'UTF8';

-- Column-specific collation
CREATE TABLE users (
    username VARCHAR(50) COLLATE "C",  -- Case-sensitive, binary sort
    email VARCHAR(255) COLLATE "en_US.utf8"
);
```

### Best Practices: String Types

✅ **Do:**
- Use VARCHAR for most strings
- Use CHAR for fixed-length codes (country codes, status codes)
- Specify reasonable max lengths (prevents abuse)
- Use utf8mb4 in MySQL (supports emojis)
- Use TEXT for long content without known limit

❌ **Don't:**
- Use VARCHAR(255) for everything (waste of space)
- Use CHAR for variable-length data (space-padded)
- Use TEXT for short strings (use VARCHAR)
- Use VARCHAR(max) without reason (hurts performance)

---

## Date and Time Types

### MySQL Date/Time Types

| Type | Format | Range | Storage |
|------|--------|-------|---------|
| **DATE** | YYYY-MM-DD | 1000-01-01 to 9999-12-31 | 3 bytes |
| **TIME** | HH:MM:SS | -838:59:59 to 838:59:59 | 3 bytes |
| **DATETIME** | YYYY-MM-DD HH:MM:SS | 1000-01-01 to 9999-12-31 | 8 bytes |
| **TIMESTAMP** | YYYY-MM-DD HH:MM:SS | 1970-01-01 to 2038-01-19 | 4 bytes |
| **YEAR** | YYYY | 1901 to 2155 | 1 byte |

### PostgreSQL Date/Time Types

| Type | Description | Storage |
|------|-------------|---------|
| **DATE** | Date only | 4 bytes |
| **TIME** | Time only | 8 bytes |
| **TIMESTAMP** | Date + time | 8 bytes |
| **TIMESTAMPTZ** | Date + time + timezone | 8 bytes |
| **INTERVAL** | Time interval | 16 bytes |

### Date/Time Examples

```sql
-- MySQL
CREATE TABLE events (
    event_id INT PRIMARY KEY,
    event_date DATE,                          -- 2024-03-15
    event_time TIME,                          -- 14:30:00
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    scheduled_for TIMESTAMP                   -- Timezone-aware
);

-- PostgreSQL
CREATE TABLE events (
    event_id SERIAL PRIMARY KEY,
    event_date DATE,                          -- 2024-03-15
    event_time TIME,                          -- 14:30:00
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    scheduled_for TIMESTAMPTZ                 -- With timezone (recommended!)
);

-- PostgreSQL trigger for updated_at
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_event_modtime
BEFORE UPDATE ON events
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();
```

### Timezone Handling

**MySQL:**
```sql
-- Convert to timezone
SELECT CONVERT_TZ(created_at, 'UTC', 'America/New_York') FROM events;

-- Set session timezone
SET time_zone = 'America/New_York';
```

**PostgreSQL:**
```sql
-- Use TIMESTAMPTZ (stores in UTC, displays in session timezone)
CREATE TABLE logs (
    log_id SERIAL PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW()  -- Recommended!
);

-- Set session timezone
SET TIMEZONE = 'America/New_York';

-- Convert to timezone in query
SELECT created_at AT TIME ZONE 'America/New_York' FROM logs;
```

### Intervals (PostgreSQL)

```sql
SELECT NOW() + INTERVAL '1 day';
SELECT NOW() - INTERVAL '3 hours';
SELECT NOW() + INTERVAL '2 weeks';

-- Store intervals
CREATE TABLE subscriptions (
    subscription_id SERIAL PRIMARY KEY,
    started_at TIMESTAMPTZ,
    duration INTERVAL  -- '1 month', '1 year', etc.
);
```

### Best Practices: Date/Time

✅ **Do:**
- Use TIMESTAMPTZ in PostgreSQL (timezone-aware)
- Store in UTC, convert to local for display
- Use DATETIME in MySQL for most timestamps
- Use DATE for birthdays, deadlines (no time needed)
- Include created_at and updated_at on most tables

❌ **Don't:**
- Use VARCHAR to store dates (use DATE/DATETIME)
- Use TIMESTAMP in MySQL for dates after 2038
- Forget timezone conversions for global apps
- Store local time without timezone info

---

## Binary Types

### Binary Data Types

**MySQL:**

| Type | Max Size | Use Case |
|------|----------|----------|
| **BINARY(n)** | 255 bytes | Fixed-size binary |
| **VARBINARY(n)** | 65,535 bytes | Variable binary |
| **TINYBLOB** | 255 bytes | Tiny binary object |
| **BLOB** | 65 KB | Binary object |
| **MEDIUMBLOB** | 16 MB | Large binary |
| **LONGBLOB** | 4 GB | Very large binary |

**PostgreSQL:**

| Type | Max Size | Use Case |
|------|----------|----------|
| **BYTEA** | 1 GB | Binary data |

### Binary Examples

```sql
-- MySQL: Store files (not recommended for large files!)
CREATE TABLE attachments (
    attachment_id INT PRIMARY KEY,
    filename VARCHAR(255),
    file_data MEDIUMBLOB,
    file_size INT,
    mime_type VARCHAR(100)
);

-- PostgreSQL
CREATE TABLE attachments (
    attachment_id SERIAL PRIMARY KEY,
    filename VARCHAR(255),
    file_data BYTEA,
    file_size INTEGER,
    mime_type VARCHAR(100)
);

-- Better: Store file path, not file itself
CREATE TABLE attachments (
    attachment_id SERIAL PRIMARY KEY,
    filename VARCHAR(255),
    file_path VARCHAR(500),  -- s3://bucket/path/to/file
    file_size INTEGER,
    mime_type VARCHAR(100)
);
```

### Best Practices: Binary

✅ **Do:**
- Store file paths instead of binary data
- Use cloud storage (S3, Azure Blob) for large files
- Store images/files in BLOB only if <1MB
- Store checksums for integrity

❌ **Don't:**
- Store large files in database (backup, replication issues)
- Use BLOB for large images/videos (use file system)

---

## Boolean Types

**MySQL:**
```sql
-- MySQL uses TINYINT(1)
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    is_active BOOLEAN DEFAULT TRUE,        -- Stored as TINYINT(1)
    is_admin TINYINT(1) DEFAULT 0          -- Same as BOOLEAN
);

-- Query
SELECT * FROM users WHERE is_active = TRUE;
SELECT * FROM users WHERE is_active = 1;
```

**PostgreSQL:**
```sql
-- PostgreSQL has native BOOLEAN
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    is_active BOOLEAN DEFAULT TRUE,
    is_admin BOOLEAN DEFAULT FALSE
);

-- Query
SELECT * FROM users WHERE is_active = TRUE;
SELECT * FROM users WHERE is_active;  -- Short form
SELECT * FROM users WHERE NOT is_admin;
```

### Best Practices: Boolean

✅ **Do:**
- Use BOOLEAN/TINYINT(1) for true/false values
- Default to FALSE for safer assumptions
- Name with is_, has_, can_ prefix
- Create indexes on boolean columns in large tables (if selective)

❌ **Don't:**
- Use CHAR('Y'/'N') or INT for booleans
- Use NULL for tristate (use explicit column)

---

## JSON Types

Store structured data in JSON format.

### MySQL JSON

```sql
-- MySQL 5.7+
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name VARCHAR(200),
    attributes JSON  -- Native JSON type
);

-- Insert JSON
INSERT INTO products (product_id, name, attributes)
VALUES (1, 'Laptop', JSON_OBJECT(
    'brand', 'Dell',
    'ram_gb', 16,
    'screen_size', 15.6,
    'has_touchscreen', TRUE
));

-- Query JSON
SELECT 
    name,
    JSON_EXTRACT(attributes, '$.brand') AS brand,
    JSON_EXTRACT(attributes, '$.ram_gb') AS ram
FROM products;

-- Using -> operator (MySQL 5.7+)
SELECT 
    name,
    attributes->'$.brand' AS brand,
    attributes->>'$.ram_gb' AS ram
FROM products;

-- Search in JSON
SELECT * FROM products
WHERE JSON_EXTRACT(attributes, '$.brand') = 'Dell';

-- Index JSON (virtual column + index)
ALTER TABLE products
ADD COLUMN brand_virtual VARCHAR(50) AS (JSON_UNQUOTE(JSON_EXTRACT(attributes, '$.brand')));

CREATE INDEX idx_brand ON products (brand_virtual);
```

### PostgreSQL JSON

```sql
-- PostgreSQL has JSON and JSONB
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(200),
    attributes JSON,   -- Text-stored, slower
    meta JSONB         -- Binary, faster, supports indexing (RECOMMENDED)
);

-- Insert JSON
INSERT INTO products (product_id, name, meta)
VALUES (1, 'Laptop', '{
    "brand": "Dell",
    "ram_gb": 16,
    "screen_size": 15.6,
    "has_touchscreen": true
}'::JSONB);

-- Query JSONB
SELECT 
    name,
    meta->>'brand' AS brand,
    meta->'ram_gb' AS ram
FROM products;

-- Search in JSONB
SELECT * FROM products WHERE meta->>'brand' = 'Dell';

-- Check if key exists
SELECT * FROM products WHERE meta ? 'brand';

-- Containment
SELECT * FROM products WHERE meta @> '{"brand": "Dell"}';

-- Index JSONB (GIN index)
CREATE INDEX idx_meta ON products USING GIN (meta);

-- Index specific JSON path
CREATE INDEX idx_brand ON products ((meta->>'brand'));
```

### Best Practices: JSON

✅ **Do:**
- Use JSONB in PostgreSQL (not JSON)
- Use for flexible, schema-less data
- Index frequently queried JSON paths
- Validate JSON structure in application
- Use for product attributes, user preferences, metadata

❌ **Don't:**
- Store relational data in JSON (use tables)
- Use JSON for data that needs foreign keys
- Store large documents (>1MB) in JSON
- Overuse JSON (prefer columns when structure is fixed)

---

## Array Types

**PostgreSQL Only** (MySQL doesn't have native arrays)

```sql
-- PostgreSQL arrays
CREATE TABLE posts (
    post_id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    tags TEXT[],                      -- Array of text
    ratings INTEGER[],                -- Array of integers
    coordinates FLOAT[][]             -- Multi-dimensional array
);

-- Insert arrays
INSERT INTO posts (post_id, title, tags, ratings)
VALUES (
    1,
    'Database Tutorial',
    ARRAY['database', 'postgresql', 'tutorial'],
    ARRAY[5, 4, 5, 3, 5]
);

-- Query arrays
SELECT * FROM posts WHERE 'database' = ANY(tags);
SELECT * FROM posts WHERE tags @> ARRAY['postgresql'];  -- Contains
SELECT * FROM posts WHERE tags && ARRAY['database', 'mysql'];  -- Overlap

-- Array functions
SELECT 
    title,
    array_length(tags, 1) AS tag_count,
    array_to_string(tags, ', ') AS tags_str
FROM posts;

-- Index arrays
CREATE INDEX idx_tags ON posts USING GIN (tags);
```

### MySQL Alternative: Many-to-Many

```sql
-- MySQL: Use junction table instead of arrays
CREATE TABLE posts (
    post_id INT PRIMARY KEY,
    title VARCHAR(200)
);

CREATE TABLE tags (
    tag_id INT PRIMARY KEY,
    tag_name VARCHAR(50)
);

CREATE TABLE post_tags (
    post_id INT,
    tag_id INT,
    PRIMARY KEY (post_id, tag_id),
    FOREIGN KEY (post_id) REFERENCES posts(post_id),
    FOREIGN KEY (tag_id) REFERENCES tags(tag_id)
);

-- Query
SELECT p.title, GROUP_CONCAT(t.tag_name) AS tags
FROM posts p
JOIN post_tags pt ON p.post_id = pt.post_id
JOIN tags t ON pt.tag_id = t.tag_id
GROUP BY p.post_id, p.title;
```

---

## UUID and Custom Types

### UUID (Universally Unique Identifier)

**MySQL (8.0+):**
```sql
-- Store as BINARY(16) for efficiency
CREATE TABLE sessions (
    session_id BINARY(16) PRIMARY KEY,
    user_id INT,
    created_at DATETIME
);

-- Insert UUID
INSERT INTO sessions (session_id, user_id, created_at)
VALUES (UUID_TO_BIN(UUID()), 123, NOW());

-- Query UUID
SELECT BIN_TO_UUID(session_id) AS session_id, user_id
FROM sessions;
```

**PostgreSQL:**
```sql
-- Enable extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE sessions (
    session_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert UUID
INSERT INTO sessions (user_id) VALUES (123);  -- Auto-generates UUID

-- Query
SELECT session_id::TEXT, user_id FROM sessions;
```

### PostgreSQL ENUM

```sql
-- Create ENUM type
CREATE TYPE status_type AS ENUM ('pending', 'active', 'suspended', 'deleted');

CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50),
    status status_type DEFAULT 'pending'
);

-- Insert
INSERT INTO users (username, status) VALUES ('alice', 'active');

-- Query
SELECT * FROM users WHERE status = 'active';
```

### PostgreSQL Custom Types

```sql
-- Composite type
CREATE TYPE address_type AS (
    street VARCHAR(200),
    city VARCHAR(100),
    state CHAR(2),
    zip VARCHAR(10)
);

CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    billing_address address_type,
    shipping_address address_type
);

-- Insert
INSERT INTO customers (name, billing_address, shipping_address)
VALUES (
    'John Doe',
    ROW('123 Main St', 'New York', 'NY', '10001'),
    ROW('456 Oak Ave', 'Boston', 'MA', '02101')
);

-- Query
SELECT 
    name,
    (billing_address).city AS billing_city,
    (shipping_address).city AS shipping_city
FROM customers;
```

---

## Type Selection Guidelines

### Decision Matrix

| Data | MySQL | PostgreSQL | Notes |
|------|-------|------------|-------|
| Primary Key (auto) | INT AUTO_INCREMENT | SERIAL | Use UNSIGNED in MySQL |
| Large PK | BIGINT AUTO_INCREMENT | BIGSERIAL | >2 billion rows |
| UUID | BINARY(16) | UUID | Distributed systems |
| Money | DECIMAL(10,2) | NUMERIC(10,2) | Never FLOAT! |
| Short text | VARCHAR(50) | VARCHAR(50) | Reasonable limit |
| Email | VARCHAR(255) | VARCHAR(255) | Standard |
| Long text | TEXT | TEXT | Articles, descriptions |
| Boolean | TINYINT(1) | BOOLEAN | is_, has_, can_ |
| Date only | DATE | DATE | Birthdays |
| Timestamp | DATETIME | TIMESTAMPTZ | Use UTC |
| JSON | JSON | JSONB | Flexible data |
| File | VARCHAR(path) | VARCHAR(path) | Store path, not data |

### Performance Considerations

**Storage Size:**
```sql
-- Smaller = better cache utilization
SMALLINT (2 bytes) vs INT (4 bytes) vs BIGINT (8 bytes)

-- Use appropriate size
-- age TINYINT UNSIGNED    (0-255, 1 byte)
-- quantity SMALLINT       (-32K to 32K, 2 bytes)
-- user_id INT             (-2B to 2B, 4 bytes)
-- big_counter BIGINT      (huge, 8 bytes)
```

**Index Efficiency:**
```sql
-- Smaller types = more entries per index page
-- INT index is more efficient than VARCHAR(255)
-- Fixed-length CHAR better than VARCHAR for index (if truly fixed)
```

### Summary Cheatsheet

```sql
-- Common patterns
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,               -- Auto-increment ID
    uuid UUID DEFAULT uuid_generate_v4(),     -- Global unique ID
    username VARCHAR(50) NOT NULL UNIQUE,     -- Short text with constraint
    email VARCHAR(255) NOT NULL UNIQUE,       -- Email (standard size)
    password_hash CHAR(60) NOT NULL,          -- bcrypt hash (always 60 chars)
    balance DECIMAL(10,2) DEFAULT 0,          -- Money (exact precision)
    is_active BOOLEAN DEFAULT TRUE,           -- Boolean flag
    birth_date DATE,                          -- Date only
    created_at TIMESTAMPTZ DEFAULT NOW(),     -- Timestamp with timezone
    updated_at TIMESTAMPTZ DEFAULT NOW(),     -- Updated timestamp
    preferences JSONB,                        -- Flexible JSON data
    tags TEXT[]                               -- Array (PostgreSQL only)
);
```

---

## References

- [MySQL Data Types Documentation](https://dev.mysql.com/doc/refman/8.0/en/data-types.html)
- [PostgreSQL Data Types Documentation](https://www.postgresql.org/docs/current/datatype.html)
- "High Performance MySQL" by Baron Schwartz
- "PostgreSQL: Up and Running" by Regina Obe
